---
layout: post
title:  "Безопасный обмен данными: ссылочные характеристики в Pony"
date:   2018-03-22 07:23:15 +0300
---

_Вольный перевод статьи: [Safely Sharing Data: Reference Capabilities in Pony](http://jtfmumm.com/blog/2016/03/06/safely-sharing-data-pony-reference-capabilities/). Эта статья — первая из планируемой серии про ссылочные характеристики в Pony. При этом, вся серия не будет  заменой [документации по этой теме](https://tutorial.ponylang.org/capabilities/reference-capabilities.html). Сначала читайте документацию, затем читайте данную серию. Но помните, практика — лучшее закрепление полученных знаний._

Допустим у вас есть три актора, которые работают параллельно. Им необходимо обмениваться данными. Что делать?

Если передавать изменяемое _(mutable)_ состояние между ними, то столкнёмся с проблемой когда акторы начнут друг-другу мешать. Допустим, _Актор 1_ пытается изменить запись в хэш-таблице _(Map)_ и в тоже время, _Актор 2_ пытается эту запись прочитать. Что получит _Актор 2_? Никто не знает!

Конечно, мы знаем что делать в этом случае: использовать блокировки. _Актор 2_ подождёт своей очереди на получение блокировки и всё будет хорошо. При этом, блокировки подразумевают координацию, а она, часто, медленная. Может _Актору 2_ и не нужна самая свежая запись? Не важно, ему придётся ждать.

«Хорошо, нам не всегда нужны блокировки! Давай воспользуемся постоянной _(persistent)_ хеш-таблицей», — скажете вы. В таком случае, _Актор 2_ сможет прочитать запись и _Актор 1_ в тоже время сможет «записать» обновление, создав копию таблицы. Но после того, как _Актор 1_ отправит свою версию таблицы _Актору 3_, _Актор 2_ уже не узнает об изменениях. А так же у _Актора 2_ имеется проблема с записью. Конечно, он может скопировать таблицу в изменяемую, но это не похоже на хорошее по скорости решение.

Должен же быть способ получше? Он есть: всего 10 ежемесячных платежей по 0 рублей каждый и вы сможете обмениваться данными быстро, безопасно и без головной боли. И всё это благодаря магии характеристик ссылки в Pony!

## Что за  ссылочные характеристики?

Продолжая предыдущий пример, представьте что у нас есть хеш-таблица со строками для ключей и строками для значений. Вероятно, мы будем хранить эту таблицу в некой переменной:

```
let m = Map[String,String]
```

Тут создаётся ссылка `m` на таблицу. Это изменяемая таблица, поэтому мы можем читать и писать в неё  когда понадобится.

Вернёмся к акторам. Если я попытаюсь отправить эту структуру в _Актор 2_, то столкнусь с проблемой. _Актор 2_ будет иметь другую ссылку на ту же таблицу. Я больше не могу писать и читать когда мне это необходимо, т.к. _Актор 2_ может писать в эту же таблицу в любой момент времени.

Это подводит нас к двум взаимосвязанным законам разделяемых ссылок, которые необходимо держать в уме при размышлении о характеристиках ссылки:

1) **Закон записи**: писать только тогда, когда  никто другой не может ни читать, ни писать.

2)  **Закон чтения**: читать только тогда, когда никто другой не может писать.

«Закон записи» обусловлен тем, что, во-первых, одновременная запись в одну структуру может привести к потере данных и, во-вторых, запись в то время, пока кто-то читает, приведёт к неожиданным результатам чтения. Независимо от того, используем ли мы блокировки или ссылочные характеристики «Закон записи» должен быть соблюдён безоговорочно.

«Закон чтения» обусловлен, что можно доверять прочитанным данным только в том случае, если никто не писал в то время, пока происходило чтение. В идеальном мире вы всегда должны доверять прочитанным данным.

В свете этих законов, можно увидеть ошибку в передаче изменяемой таблицы без предварительных действий. Учитывая то, что оба актора независимы друг от друга, то ни у кого из них нет возможности узнать читает или пишет другой. Так что без блокировки можно получить неприятности.

Нам необходима такая возможность, когда актор точно знает, могут ли другие акторы читать или писать в используемую им структуру данных. Тут и появляются ссылочные характеристики. Они запрещают некоторые комбинации чтения и записи локально или глобально. 

Идея покажется знакомой если у вас уже есть опыт в использовании неизменяемых данных. Ссылка на неизменяемые данные запрещает запись для всех. Если я отправляю неизменяемую структуру данных, то уверен, что на эти данные действует «Закон чтения», т.к. никто не сможет в них что-то  поменять.

В `Pony` есть похожая возможность, но с более тонким контролем. Например, рассмотрим идею передачи изменяемых данных. Всегда ли это плохо? Не всегда. В приведённом выше примере есть ссылка `m` на изменяемую таблицу. В локальной области, `m` — единственный способ сослаться на таблицу и единственный способ что-то в неё записать. Можем ли мы отправить эту таблицу в _Актор 2_ без риска нарушить оба закона? Должны ли мы сначала преобразовать её в неизменяемую структуру данных? 

На самом деле нет. Вместо преобразования, надо уничтожить ссылку на таблицу перед её отправкой в _Актор 2_. Если `m` больше не будет существовать в локальной области, то и не будет больше возможности читать или писать в таблицу. И нас не должно волновать что будет делать _Актор 2_ с этими данными.

В `Pony`, если у нас есть только одна ссылка на изменяемую структуру данных, то она имеет характеристику `iso`, что значит «изолированная» (`iso` происходит от слова `isolated`). `iso` указывает на изменяемые данные, но её можно безопасно передать в другие акторы в тот момент, когда мы откажемся от этой ссылки.

Но что если нам нужно продолжать чтение из данной таблицы и при этом мы хотим передать другим акторам такую же возможность? Этот случай уже для неизменяемой структуры данных. Неизменяемые данные — это единственный способ гарантировать что несколько акторов подчиняются «Закону чтения» по отношению к одной и той же структуре данных. В `Pony`, ссылка на неизменяемую структуру данных, которая может быть передана между акторами, имеет характеристику `val`. Она гарантирует что никто не сможет изменить данные, но все смогут их читать.

В системе акторов, акторы отправляют друг другу сообщения. Для отправки сообщения _Актору 3_ вы храните на него ссылку. Какую характеристику должна иметь эта ссылка? Это не `iso` по двум причинам: во-первых, из актора нельзя читать или писать напрямую, во-вторых, может потребоваться, чтобы к _Актору 3_  одновременно имели доступ и другие акторы и это не возможно для изолированной ссылки. Что насчёт `val`?  Чуть выше я сказал, что  из актора нельзя читать напрямую, а `val` запрещает только запись.

Нам требуется что-то, что можно пересылать многим акторам, но что одновременно запрещает чтение и запись. В `Pony` это называется `tag`.  По сути, это ссылка на идентификатор данных. Если в качестве передаваемых данных выступает сам актор с доступным поведением для других акторов, то всё что нам потребуется — `tag` с возможностью вызывать это поведение, но без возможности напрямую читать или писать в него.

## Основа ссылочных характеристик

По мере погружения в работу ссылочных характеристик полезно помнить о ключевой причине их существования: безопасном обмене данными между акторами. Эта безопасность будет проверена во время компиляции. Это ещё и означает, что наиболее важными ссылочными характеристиками являются те из них, которые могут **пересылаться** между акторами, а именно `iso`, `val` и `tag`, которые мы обсудили ранее. Запомните их как основу ссылочных характеристик в `Pony`.

Эти пересылаемые характеристики имеют следующие отношения тип -> подтип:

`iso –> val –> tag`

Обратите внимание, что если мы ожидаем в акторе `tag`, то можем принять любую характеристику. Потому что `tag` запрещает чтение и запись. Поэтому, наш код, который ожидает `tag` никогда не попытается прочитать или что-то записать в него, т.е. мы не нарушим законы чтения и записи. Таким образом, код может обрабатывать `iso`  и `val` как подтипы `tag`.

Так же, можно заметить что `val` является подтипом `iso`. Когда мы передаем `iso`, то отказываемся от ссылки и это означает, что никто, кроме получившего её актора, о ней больше не знает. Соответственно, если вы единственный, кто владеет ссылкой, то вы можете решить какую характеристику ей указать для последующей передачи. Любой код, который ожидает `val`, может так же получить `iso` преобразованный к `val`. Это возможно потому что компилятор проверит, что никто не будет писать в `iso`, что как раз и подходит для `val`.

## Ссылочные характеристики при работе в локальной области

Пересылаемые характеристики, которые указывают что данными можно обмениваться между акторами, не единственные. В `Pony` так же есть ещё три характеристики, которые будут полезны в рамках одного актора. Они называются `ref`, `trn` и `box`. Внутри актора выполнение программы является последовательным и синхронным. Т.е., внутри актора мы не подвержены опасностям, которые могут нарушить законы записи и чтения. Если нет параллелизма, то нет и конкурирующих записей и чтений при записи.

В этом смысле, внутри одного актора нет необходимости задумываться об этих законах. Поэтому, один актор может хранить столько ссылок на изменяемую структуру данных, сколько потребуется. Ссылка на изменяемые данные, которая ничего не говорит о том, сколько ещё подобных ссылок может существовать в локальной области, называется `ref`. Воспринимайте `ref` как обычную ссылку из других языков программирования.

В `Pony` допустим такой код

```
  let m: Map[String, String] ref = Map[String, String]
  let n = m
  let o = m
```

Если `m` была бы ссылкой с характеристикой `iso`, то вторая строка не позволила бы программе скомпилироваться. Потому что можно иметь только одну `iso`-ссылку. С другой стороны, на `ref` локально может быть сколько угодно ссылок.

Допустим, у нас есть структура данных, которая в данный момент изменяемая, но позже станет неизменяемой. Например, мы подсчитываем голоса участников за определённый промежуток времени для голосования. Как только время закончится, больше не надо будет изменять записи о проголосовавших. И в этот момент можно свободно отправлять данные другим акторам. Другими словами, нам надо получить характеристику `val`.

Если при подсчёте голосов использовать `ref`, то можно столкнуться с проблемой. Как только голоса будут подсчитаны, необходимо найти все существующие `ref`-ссылки и уничтожить их. Это единственный способ доказать, что никто не будет пытаться что-то записать в момент чтения из `val`. Для таких случаев в `Pony` есть специальное решение — ссылочная характеристика для превращения, которая называется `trn` _(transition)_.

`trn`-характеристика позволяет запись, но не допускает других ссылок, которые так же позволяют запись. В отличие от `iso`, эта характеристика разрешает ссылки, которые позволяют только чтение. Причина, по которой разрешается иметь более одной читающей ссылки в том, что мы ограничены одним актором. Соответственно, мы точно знаем, что одновременное чтение при записи невозможно _(как указано выше, в рамках одного актора будет либо только чтение, либо только запись)_.

Локальные ссылки для чтения могут быть помечены характеристикой `box`. Эта характеристика позволяет локально читать, но не писать. В ходе подсчёта голосов другие структуры данных могут ссылаться на `box` (например, некий объект может принимать решение на основе текущего подсчёта). При наступлении момента, когда надо «заморозить» голосование и конвертировать в неизменяемые данные, все эти ссылки на `box` останутся безопасными. Можно конвертировать `trn` в `val`.

## Преобразование между характеристиками

Каким образом можно преобразовать `trn` в `val`. И в более общем плане, каким образом можно преобразовывать характеристики? Существуют два направления по которым происходит преобразование. Первое: в соответствии с набором правил подстановки, которые моделируются в терминах подтипов. Второе: путём «подъёма» характеристик, т.е. процесса, который называется извлечением _(recovery)_. Начнём с подстановки.

### Подстановка

Посмотрите на диаграмму подстановки:

```
                --> ref --
              /            \
iso --> trn --              --> box --> tag
              \            /
                --> val --
```

Читайте стрелки на диаграмме как «является подтипом» или «может быть передана как». Например, `iso --> trn` интерпретируется как «характеристика `iso` может быть передана как `trn`». Это отношение транзитивно, т.е. характеристика `iso` может быть передана как любая другая ссылочная характеристика.

Так происходит потому что, если отказаться от `iso`-ссылки, то эти данные можно пометить любой ссылочной характеристикой. Для того, чтобы отказаться от ссылки надо использовать `consume`. Например:

```
  let a: Map[String, String] iso = recover Map[String, String] end
  let b: Map[String, String] trn = consume a

  let c: Map[String, String] iso = recover Map[String, String] end
  let d: Map[String, String] val = consume c
```

Позже я объясню что означает `recover`, сейчас воспринимайте это как способ указать ссылке на таблицу _(`Map`)_ характеристику `iso`.

Того же эффекта можно достичь с помощью поглощения _(consume)_ ссылки при передаче `iso`. Те же рассуждения применимы и к `trn` при подстановке этой характеристики вместо любой кроме `iso` в момент отказа от ссылки. `trn` гарантирует, что существует только одна ссылка с возможностью записи и при поглощении она уничтожается.

Почему нельзя подставить `trn` как `iso`? Потому что можно иметь много локальных читающих `box`-ссылок на `trn`. Это означает, что при поглощении `trn` на него могут остаться читающие ссылки. Соответственно, если существуют другие ссылки, то характеристика `iso` уже не может быть получена, т.к. она может быть только в единственном экземпляре.

Можно подставить `ref` или `val` в качестве `box`, т.к. `ref` и `val` доступны локально на чтение. `box` не говорит о том, что не могут существовать ссылки доступные запись. Эта характеристика говорит о том, что `box` не является доступной на запись. Соответственно, она согласуется как с локально изменяемыми данными, так и глобально неизменяемыми. Это позволяет написать метод, который получает как `ref`, так и `val` если аргумент нужен только для чтения.

И наконец, по причинам рассмотренным выше, любая ссылочная характеристика может быть передана в качестве характеристики `tag`. Потому что из `tag` нельзя ни читать, ни писать. Соответственно, при передаче ссылки c характеристикой `tag` можно быть уверенным, что  никакие гарантии не будут нарушены.

### Извлечение

Подстановка — это концепция связи между ссылочными характеристиками, другая точка зрения на три категорий: изменяемое, неизменяемое и непрозрачное.

1) **Изменяемая**  характеристика не запрещает ни запись, ни чтение. Эта категория включает в себя `iso`, `ref` и `trn`.

2) **Неизменяемая**  характеристика запрещает запись, но не запрещает чтение. Эта категория включает `val` и `box`.

3) **Непрозрачная**  характеристика запрещает и запись и чтение. Она содержит только `tag`.

Надо отметить, что в каждой категории есть только одна пересылаемая характеристика.

Извлечение позволяет превращать одну характеристику в другую с помощью защищённого блока `recover`.  Я называю его «защищённым», потому что внутри блока обращения могут идти только к пересылаемым ссылкам из внешней области (т.е. имеющим характеристику `iso`, `val` и `tag`). Внутри блока можно создавать ссылки с любыми характеристиками (придерживаясь правил ссылочных характеристик). Значением `recover`-блока будет значение его последнего выражения. Все остальные ссылки, созданные внутри блока, будут уничтожены после его завершения.

Из блока `recover` можно извлечь значение в соответствии со следующими тремя правилами:

1) **Изменяемая** характеристика может быть извлечена в изменяемую, неизменяемую или непрозрачную, т.е. в любую. Для характеристик `iso` и `trn` необходимо поглотить её ссылку до извлечения во что-то другое.

2) **Неизменяемая** характеристика может быть извлечена в неизменяемую и непрозрачную.

3) **Непрозрачная** характеристика может быть извлечена только в непрозрачную. Т.е. характеристика `tag` может быть извлечена только в `tag`, что бесполезно на практике.

Эти правила можно упростить запомнив то, что неизменяемая ссылочная характеристика может быть извлечена в неизменяемую или непрозрачную, а изменяемая — в любую.

Почему так? Пока проигнорируем ссылки из внешней области. Мы знаем что всё, что происходит внутри блока `recover` невидимо снаружи. Если мы создадим кучу `ref`-ссылок и вернём только одну из них в конце блока, то будет безопасно извлечь её как `iso` потому, что все остальные ссылки будут уничтожены после завершения блока. Таким образом, будет существовать только одна ссылка. И конечно, если ссылка единственная, то можно ей указать любую характеристику (как обсуждалось в секции про подстановку). Это объясняет почему изменяемая ссылка, созданная внутри блока, может быть извлечена с любой характеристикой.

Но так же, есть возможность использовать ссылки и из внешней области, если они пересылаемые.  Очевидно, что если нам надо вернуть позаимствованную ссылку с `iso`-характеристикой, то её необходимо поглотить до извлечения. Иначе, у нас будет две ссылки на `iso`, что запрещено. Используйте `consume` для `iso` перед возвратом из блока:

```
 let lst: List[String] iso = recover List[String] end
 let vlst: List[String] val = recover val
   lst.push("hi")
   consume lst
 end
```

В этом примере ссылка `lst` получила характеристику `iso`. Во втором боке `recover` мы добавили значение в `lst` и вернули её. Но, так как, перед возвратом мы её поглотили `consume`, то теперь знаем, что больше нет других ссылок. После этого у нас появилась возможность извлечь её с характеристикой `val`, как в примере, или с любой другой.

Почему нельзя конвертировать неизменяемую характеристику в изменяемую? Допустим, мы позаимствовали ссылку с характеристикой `val` из внешней области, как в этом (нерабочем) примере:

```
  let vlst: List[String] val = recover val List[String] end
  ... // здесь мы что-то делаем с vlst, например передаём другим акторам
  let rlst: List[String] ref = recover ref
    consume vlst
  end
```

Потребление  `vlist` в `recover`-блоке не сделает ничего полезного потому, что мы не знаем сколько ещё ссылок существует. Т.к. ссылка `vlist` имеет характеристику `val` то она может быть отправлена другим акторам, даже если мы удерживаем эту ссылку локально. Таким образом, её извлечение с характеристикой `ref` нарушает оба закона обмена данными. Все считают, что ни у кого другого нет прав на запись, а захват `ref`,  говорит о том, что ни у кого не будет прав на чтение.

Если вы сравните эти два примера, то заметите, что в примере создания ссылки с характеристикой `iso` написано:

```
  recover List[String] end
```

В другом примере, при создании характеристики `val`, написано:

```
  recover val List[String] end
```

Разница объясняется поведением по-умолчанию блока `recover`. Вспомните, что в каждой категории есть только одна пересылаемая характеристика: `iso` для изменяемого, `val` для неизменяемого и `tag` для непрозрачного. Поведением по-умолчанию блока `recover` является извлечение ссылки с пересылаемой характеристикой соответствующей категории. Таким образом, любая изменяемая ссылочная характеристика по-умолчанию извлекается в `iso`, любая неизменяемая — в `val`.

## Что дальше?

В этой статье охвачено не всё, что есть в `Pony` относительно ссылочных характеристик, но мы рассмотрели основы. Для введения этого достаточно.
